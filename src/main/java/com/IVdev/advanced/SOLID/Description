При создании сложных проектов нужно придерживаться принципов, дабы по возможности расширять функционал, не модифицируя по возможности уже написанный код. Проект пишется так, чтобы в будущем было удобно его расширять и модифицировать, чтобы он был модульный, читабельный. Для этого есть принципы SOLID.

S - Данный принцип гласит: никогда не должно быть больше одной причины изменить класс. На каждый объект возлагается одна обязанность,
полностью инкапсулированная в класс. Все сервисы класса направлены на обеспечение этой обязанности. Т.е. каждый класс ограничен своей задачей.
На примере с Computer: если в будущем надо будет сохранять данные еще куда-то — на облако либо в БД — нам придется этот класс дописывать, это нехорошо.
Логику сохранений надо вынести в отдельный сервис.

O - Open Closed Principle (Принцип открытости/закрытости): программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения,
но закрыты для изменения.
На примере с Computer: каждый сэйвер должен выполнять свою работу, т. е. Не должно в одном сервисе быть сохранения и на диск, и в облако, и в БД.
Сервис должен быть узкоспециализирован. Для этого вводятся интерфейсы с единственным методом для переопределения. Нет необходимости добавлять новый функционал в
текущий класс, нужно переопределять метод интерфейса в новом классе.

L - Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).Это вариация принципа открытости/закрытости, о котором говорилось ранее.
Его можно описать так: объекты в программе можно заменить их наследниками без изменения свойств программы, т. е.
Дочерний класс должен полностью повторять функционал своего базового класса. Работа методов родительского класса при вызове из наследника д.б. такой же, как если бы метод вызывался из родителя.
На примере с Computer: OmenHP переопределяет метод setData родительского класса неверно, добавляя новый функционал к нему.
Я ожидаю, что метод setData отработает так же, как в родтельском классе, но тест падает с ошибкой.

I - Interface Segregation Principle (Принцип разделения интерфейса).Характеризуется следующим утверждением: клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.
Т.е. нужно создавать узкоспециализированные интерфейсы, предназначенные для конкретного клиента.
На примере с  интерфейсом Shape: все три класса переопределяют его три метода, но реализуют лишь один из них, два другие висят в воздухе.
Нужно создать три узкоспец.интерфейса с одним методом для каждого класса.

D - Dependency Inversion Principle (Принцип инверсии зависимостей): зависимости внутри системы строятся на основе абстракций.
Классы в системе должны зависеть от интерфейсов/абстр.классов, а не от конкретных классов и функций.
На примере с ModelForm:класс ModelForm описывает сущность для БД, WebFramework работает с сущностью посредством MySQL, MySQL сохраняет ее в БД.
Тут плохо то, что 2 класса завязаны плотно на ModelForm, коих может быть множество. Нужно создать интерфейс Iform,
все типы моделей будут от него имплементироваться